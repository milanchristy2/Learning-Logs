Rest - > simple stateless follows 
1. What is REST?
REST (Representational State Transfer) is an API architectural style used to design web services.
In REST:
Everything is treated as a resource
Resources are identified using URLs
Communication happens over HTTP
Data is usually exchanged in JSON
Example
https://api.example.com/users/101

2. Key Principles of REST
Client–Server Architecture
Client and server are separate; they communicate via requests and responses.
Statelessness
Each request contains all the information needed.
The server does not store client state.
Uniform Interface
Standard HTTP methods are used.
Resource-Based
Data is accessed via resource identifiers (URIs).
Cacheable
Responses can be cached to improve performance.

REST HTTP Methods and Their Components
Each REST method consists of components:
HTTP Method
URL (Endpoint)
Headers
Request Body (if applicable)
Response

1. GET – Retrieve Data
Used to fetch data from the server.
Components
Method: GET
URL: /users/101
Headers: Authorization, Content-Type
Body: ❌ Not used
Response: Data + status code

Example
GET /users/101
Common Status Codes
200 OK
404 Not Found


2. POST – Create New Resource
Used to send data to the server to create a new resource.
Components
Method: POST
URL: /users
Headers: Content-Type, Authorization
Body: Data to create resource
Response: Created resource
Example


Example
POST /users
{
  "name": "Alice",
  "email": "alice@example.com"
}
Common Status Codes
201 Created
400 Bad Request

3. PUT – Update Entire Resource
Used to replace an existing resource completely.
Components
Method: PUT
URL: /users/101
Headers: Content-Type
Body: Complete updated data
Response: Updated resource
Example
PUT /users/101
{
  "name": "Alice Smith",
  "email": "alice.smith@example.com"
}
Common Status Codes
200 OK
204 No Content

4. PATCH – Update Partial Resource
Used to update part of a resource.
Components
Method: PATCH
URL: /users/101
Headers: Content-Type
Body: Only fields to change
Response: Updated resource
Example
PATCH /users/101
{
  "email": "newemail@example.com"
}
Common Status Codes
200 OK

5. DELETE – Remove Resource
Used to delete a resource.
Components
Method: DELETE
URL: /users/101
Headers: Authorization
Body: ❌ Usually not used
Response: Confirmation
Example
DELETE /users/101
Common Status Codes
Common Status Codes
200 OK
204 No Content

| Method | Purpose     | Request Body | Example      |
| ------ | ----------- | ------------ | ------------ |
| GET    | Read data   | ❌ No         | Get user     |
| POST   | Create data | ✅ Yes        | Add user     |
| PUT    | Update all  | ✅ Yes        | Replace user |
| PATCH  | Update part | ✅ Yes        | Modify user  |
| DELETE | Delete data | ❌ No         | Remove user  |




5. REST Request–Response Components (Exam-Friendly)
Request Components
HTTP Method
URL / Endpoint
Headers
Body (optional)
Response Components
Status Code
Headers
Response Body




POST /users HTTP/1.1
Host: api.example.com
Content-Type: application/json

{
  "name": "John"
}

Concurrency vs Parallelism

| Feature          | Concurrency                 | Parallelism                |
| ---------------- | --------------------------- | -------------------------- |
| Meaning          | Managing many tasks at once | Running many tasks at once |
| Execution        | Tasks overlap in time       | Tasks run simultaneously   |
| CPU cores needed | Single or multiple          | Multiple required          |
| Focus            | Structure & design          | Performance & speed        |
| Switching        | Context switching           | No switching               |
| Best for         | I/O-bound tasks             | CPU-bound tasks            |
| Example          | Async API requests          | Multi-core data processing |


Components 

URL ENDPOINT 
Headers
Request Body
Response




| HTTP Method | Purpose                   | Used For                 | Request Body | Idempotent* | Example                |
| ----------- | ------------------------- | ------------------------ | ------------ | ----------- | ---------------------- |
| **GET**     | Retrieve data from server | Reading a resource       | ❌ No         | ✅ Yes       | Get user details       |
| **POST**    | Send data to server       | Creating a new resource  | ✅ Yes        | ❌ No        | Create new user        |
| **PUT**     | Replace existing resource | Updating entire resource | ✅ Yes        | ✅ Yes       | Update user completely |
| **PATCH**   | Modify part of a resource | Partial update           | ✅ Yes        | ❌ No        | Update email only      |
| **DELETE**  | Remove a resource         | Deleting data            | ❌ No         | ✅ Yes       | Delete user            |
| **HEAD**    | Retrieve headers only     | Check resource existence | ❌ No         | ✅ Yes       | Check if file exists   |
| **OPTIONS** | Get allowed methods       | CORS & API discovery     | ❌ No         | ✅ Yes       | Allowed API methods    |
| **TRACE**   | Echo request              | Debugging                | ❌ No         | ❌ No        | Test request path      |
| **CONNECT** | Create tunnel             | HTTPS via proxy          | ❌ No         | ❌ No        | Secure tunneling       |


monolithic and microservices Architecture

controller layer-> service layer->repostiory layer 


client->controller layer->service layer->repostiory layer (db)

controller layer-> layer to write controller is the first entry point of the fastapi application which have the apis that client calls
cl-> takes the requests no business logic and forwards the request to service layer in order to do some processing of business logic
cl-> get the data from the client and forward it to service and whatever service is returning and forward it to the client

service layer-> all the business operations happen in the service layer any modifications or population of the data
sl-> this layer forwards it to repostiory layer and calls the repostiory layer

repostiory layer-> is to talk to the database fetch the data from db and return it to the service layer
service layer-> takes ther response from the repostiory layer and give it to controller layer

even service layer can talk to database and fetch the data but it is not good practice 

src/
app/
│
├── main.py
│
├── api/
│   ├── v1/
│   │   ├── routes/
│   │   │   └── user_controller.py
│   │   └── router.py
│
├── services/
│   └── user_service.py
│
├── repositories/
│   └── user_repository.py
│
├── models/
│   └── user_model.py
│
├── schemas/
│   └── user_schema.py
│
├── db/
│   ├── database.py
│   └── session.py
│
└── core/
    └── config.py


Client
  ↓
Controller (API Route)
  ↓
Service (Business Logic)
  ↓
Repository (Database)
  ↓
Database

why do we need a translator?
computer program is written in high level programming language(humans can understand better) low level programming language(machine can understand better)
machines can only understand 0s and 1s and not high level programming language
translator is a piece of software that converts a high level programming language to binary language which can be understood by machines
types of translator-> compiler and interpreter

compiler-> is a complex piece of software used to convert source code to binary code in one go
c is complied programming language

machine(complier)-> executable code(.exe in windows and .app in macos)

pass the executable code to another machine and compile it to produce the output

sum.c,.exe and sum.o
sum.o->object file 
.exe executable can run on any windows machine
the other machine can just take this executable and run it

interpreter->software program written to translate source code to machine code line by line

machine-> has the soruce code
then copy of source code is sent to other machine
interpreter must be installed in other machine
interpreter translates the code on the fly(run time) line by line
interpreter never generates an executable translate each line of code at run time and generate output on the screen
browser is example for interpreter

python is both interperted and compiled language(hybrid language)
source code(.py)->compiler(bytecode .pyc)->virtual machines(interperter is part of it which generates machine code on the fly and see the output generated)

to see the bytecode use the module py_compile py_compile.compile()


networking concepts
ip address->identifier house address for mail delivery 
http request-> http response<-(public ip address)

domain name system
translates ip address to human readable names so that browser can find the website

ports->numbered channels on a server ranging from 1 to 65535
different apps listen on different ports
standard ports-> 80(web apps),3306(mysql)
every port is unique for every device and every app needs a port 

network segementation 
subnets-> let us divide our network into seperate sections
frontend servers(public facing)->subnet A(ip->10.0.1.x)
application->subnet B(10.0.2.x)
database-> subnet C(10.0.3.x)

routing directs traffic between different routing segments
when the network needs data from the database router will determine the path (gps for network data)

firewalls->security guard that checks every piece of traffic and decides whatever to allow based
on the rules we set 
host firewalls network firewalls

private ip address work inside your own network

network address translation allows multiple devices with private ip address  to share one public ip address when accessing the internet

all the backend servers can reach the internet through one ip address

moving to cloud-> someone else manages the hardware and  increase or decrease our capacity

need -> ip,ports,subnets,routing,firewalls,nat

virtual private cloud-> isolated section of cloud provider's network

internet gateway to connect our public subnets to the internet


microservices Architecture

containers packs everything an application needs

container networks
bridge network->all containers connected to the same bridge network can communicate
with each other using just container names
port mapping
overlay networks->virtual network that spans multiple hosts making containers appear on different servers
as if they were on the same network

kubernetes-> automotes container management
pod-> basic unit group of one or more containers that work closely together in a container per pod
kubernetes services-> stable ip address dns name that will never change

k8 clusters

ingress-> single ingresss can handle all incoming traffic into the cluster and route it to
correct cluster based on the rules we configured


monolithic Architecture-> the application is treated as a single unit
where frontend,backend and database are all part of one codebase and usually one deployment

Characteristics
Single codebase
Single database
Single deployment unit
Components are tightly coupled

Advantages
✔ Simple to develop (good for beginners)
✔ Easy to deploy
✔ Easier debugging
✔ Less infrastructure needed

❌ Disadvantages
❌ Hard to scale specific features
❌ Large codebase becomes hard to maintain
❌ One bug can affect entire app
❌ Slower deployments as app grows


microservices architecture-> breaks the application into small and independent services
Each service:
Has a single responsibility
Runs independently
Communicates via HTTP / REST / gRPC / message queues
Can be deployed independently

Characteristics
Multiple small services
Each service has its own database
Independent deployment
Loosely coupled
Communicate via APIs


Advantages
✔ High scalability
✔ Fault isolation (one service fails, others still work)
✔ Faster deployments
✔ Different technologies per service
✔ Easier for large teams


❌ Disadvantages
❌ Complex architecture
❌ Harder to debug
❌ Network latency
❌ Requires DevOps skills
❌ More infrastructure cost

| Feature         | Monolithic | Microservices           |
| --------------- | ---------- | ----------------------- |
| Codebase        | Single     | Multiple                |
| Deployment      | One unit   | Independent services    |
| Scalability     | Entire app | Per service             |
| Database        | Single     | Per service             |
| Technology      | Same stack | Can vary                |
| Fault isolation | Poor       | Excellent               |
| Complexity      | Low        | High                    |
| Best for        | Small apps | Large, scalable systems |


Transport layer security 
tcp handshake  certificate check key exchange and data transmission

assymmetric encryption(public key,private key)

RSA is a method for session key exchange
BUT nowadays diffie-hellmen is a more comman way of exchanging session key


vertical scaling-> add more resources like ram or upgrade the cpu of the server(very limited)
replicas(better approach)-> to handle a subset of requests

horizontal scaling-> more powerful because it adds redudancy and fault tolerance this elimnates
single point of failure (complicated process)

load balancer->server known as reverse proxy directs incoming requests to the appropirate server

algorithm-> round robin which balance by cycling through our pool of servers 
hashing-> hashing the incoming request id

content delivery networks->network of servers located all around the world

caching-> creating copies of data so that it can be refetched faster in the future

ip address

tcp/ip 
dns-> googledomains

https(application layer protocol)

api paradigms-> rest,graphql,grpc
grpc framework-> used for server-server communication  

protocol buffers vs json

websocktes-> supports bidrectional comunication 

database mangement systems
consistency 
sharding
replication-> leader-follower replication leader-leader replication
CAP theorem->to weigh tradeoffs with replicated design consistency avaliability and partition

message queues->data can be persisted using them and many apps can become decoupled 

RAG

1.fetch relevant information from database
2.when querying the LLM 
3.at that time we give question + context from db
4.use this information to answer the question 


SSL stands for Secure Socket layer protocol that encrypts data that is transmitted between computers
TLS stands for Transport Layer Security newer version of SSL but with best secuirty practices

SSL is depreciated way back 2015
if it is http-> unsecure
https-> 's' being secuirty

handshake-> browser and server engage in an handshake to establish secure connection


client-> client hello -> server
server-> server hello and also sends ssl certificate -> client

git config --global user.email


JWT(JSON web token)
CLIENT access some protective data of the server
SERVER knows clients cannot be trusted and server only gives the data for trustworthy client
1.client sends a request to the server get /login with username and password
2.server creates a jwt token
3.this token is returned to client {token:'token'}
4.client sends a copy of jwt when making a request 
5.server checks for jwt signature
6.server sends a response to client {message:"hello"}


MVC(model view controller)
architectural pattern (govers the whole architecture of the application) design patters are used to solve specify arch problems
mvc divides a software application in 3 parts ->model,view and controller (sepeartion of concerns)

client->server->database
client sends a request to the server and there is a layer at the begining of the server namely blue which interacts with the 
database and fetchs the necessary Data
model cannot fetch the data directly because the red is specialized in talking to the database
now blue will parse the information to red and red interacts with the database and fetchs the necessary data and sends it to 
blue and blue should ideally send the data to client but it has raw data(not in human readable format)
another layer called green specializes in presenting data to the client
blue gives raw data to green and green formats the data(takes the raw data and arrange them in tabular format or applying some styling)
this formatted data is sent to the client this is how mvc works
red: model
green: view
blue: controller
client sends a request to the server then controller takes that request to model then model interacts with database and in the process
may execute some bussiness logic required after getting data from database it passes to the controller
controller now passes the data to view view formats the data this data is sent to the client
model interacts with database and responisble for executing business logic(deals with data)
view is what viewers sees on the screen generates user interface for the user 
controller takes the input(request parameters) also interacts with model and view acts like a middle man between our model and view
in java 
model -> java class
view -> jsp page
controller -> servlet  or servlet filter

high level controller layer
1. routing-> it has a list of routes  url route and http method defined which is triggered by the user and specific data is
present for that particular route
2.request validation layer(middlewares)-> the incoming input request(request body) and wants some of the parameters for processing
it validates the incoming request whether it follows the api contract or not it can directly revert back to the routing layer
we can multiple validation 
this layer sends the request to the controller layer if all the validation checks are done
3. controller layer-> to call the model layer and prepare the response object 
takes the request from routing and middlewares and pass the request to the to the model part and prepare the response object  
of each layer is of seperate directory
routing handles the detials of incoming routes and http methods which route and http method is allocated to which controller and 
middleware
middleware handles validation 

high level model layer
request it brought to the service layer
1.service layer-> any business logic is going to reside inside this layer
any business logic should never reside inside the controller layer
2.repository layer-> will never contain the business logic it will contain interfaces and methods using which you will fetch the data
repostiory layer will technically communicate with the databases
3. high level model layer-> defines the programming interface of the databases (inside the databases the kind of data being stored)
(storing email password user_id username address of user ) like userclass stored user stored in the database
how the data will be stored in db -> model layer


config folder-> any kind of configurations like environment variables or any kind of configurable data 
utils folder-> helper methods that is reusable in multiple parts of the codebase like converting your time into a particular format
this function can be reuse in multiple places in the codebase

client (react/nextjs project)-> routing layer (this maps the http method and url routes that are supported by our app get/ping)
routing layer-> middleware(it validates the incoming request details like request body to create a product you would need like name,city,detials of product)
like mandatory details of the product
middleware-> controller layer(this layer forwards the request to the server layer takes repsone from service layer and prepare http response object)
keep this in mind-> no business logic controller should be thin there should be any bloating or too much logic should not be there
in controller 

controller layer-> service layer(all the business logic goes inside this layer) alogrithm to match the user and the cab driver
so all this goes inside the controller layer 
keep this in mind-> each layer is a folder and every folder will have multiple files then forwards the request for executing business logic
and needs data
service layer-> repoistory layer(this layer is responible for providing data to service layer)
maybe same type of data might be required in multiple services like service matching users and riders or service mantaining details of the user
one service shows the rider's history so multiple services needs the same kind of data 
not requeired to implment the same kind everywhere one method in repo layer and everyone will call that method

database-> actual data exists here

repository layer->models(gives blueprint about how the data should in the database they mainly have classes)
(these classes represnets how the data will look in the database)

optional folders
config folder-> this contains any configuration example-> env variables
utils folder-> any reusable helper methods goes here 

model represnets how the data looks in the database
repoistory contains the logic to retrieve the data from the database 
connect to the database servers there is tcp connection setup between your codebase and database then query the data
some languages/frameworks repo layer directly connects to the database
model has one responsibility to determine how the data looks in the database

database returns data in the form of json
actual classes is present inside the models 
but in some languages/frameworks repo layer cannot communicate directly to the database and instead the logic for db connection exists within 
the models

raw querys can be written in the repo layer use case of migration of services and representing the data and fetching of the data
make the code as modular as possible 


JWT
It is a widely used mechanism to secure the authentication to secure your endpoints
this is nothing but a token having three parts
and each part is sepearted by dots
firstpart.secondpart.thirdpart(example)

firstpart -> header(alogrithm used to create the necessary token using HS256)
this does not change and remains the same

secondpart-> payload(user's information) like user_id,user_name,token_issued,token_expiration
expiration issue iat: issued_at time is usually written in long

jwt expires(the token is not valid anymore)

signature->secrets to store secret data like env variables
the secret is used to create this token 
you need a 
header(algo used to create the jwt token)
payload(user's information)
secret key(this is hidden)

1.creating a jwt token
base64url is used to convert any special characters like "",.,/,'' etc into a basic string
simple encoding
and can be easily decoded

encoded header.encoded payload.secretkey(adding a dot and concatenating them )
then secret key is taken and alogrithm like HMACSHA-256 is implmeneted
and the input for this secretkey and concatenation of header and payload
and finally an encoded signature is formed the algorithm splits 
"." concat-> jwt token

jwt is basically used for encoding

2.validating a jwt 

client-> server(sends username and password for /login endpoint)
this validates credentials and raise a token generation request
send jwt token as a response
use access token to make a request 
(you give me this token and i need to use this service)

token-> first part and second part and third part will be seperated
takes the first and second parts secret key being stored in the server
secret key will be avaliable at the time for token verification 
the same algo used to make another encoded signature
the new encoded signature and the previous signature is compared to check for equality
if they are equal they are valid if not invalid

if access token is valid fulfill the request(server checks for validating the token)

jwt is basically used to prove this token is generated by you 


RAG
main motivation of rag is connecting llms to external data 

retrieval augmented generation(rag)
question-> (database<-documents)[indexing]->(relevant document)[retrieval]->(context window)[generation]->answer

query translation
routing
query construction
indexing
retrieval
filtering
generation(active rag)

indexing
1.document loading: question->retriever retriever<-load documents   retriever->relevant docuemnts 
representation of similarity is typically done using numerical or text representation because it is easy to compare with vectors
statistical and machine learned representations

statistical->bag of words->representation(sparse)->search(bm25)
machine learned->embedding->dense->knn,hnsw

loading,splitting and embedding
embedding models have small context windows these docuemnts are split and each document is compressed into a vector
vector captures the semantic meaning of the document itself

a simple rag -> prepare the data, query for retrieval data and craft the response

data soruce

original text->text splitter->chunks of text->embeddings

embeddings are representation of text to capture their meaning literally list of numbers in python